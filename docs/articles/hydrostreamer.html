<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>hydrostreamer tutorial • hydrostreamer</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="hydrostreamer tutorial">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">hydrostreamer</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/hydrostreamer.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mkkallio/hydrostreamer">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>hydrostreamer tutorial</h1>
                        <h4 class="author">Marko Kallio</h4>
            
            <h4 class="date">2018-06-12</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mkkallio/hydrostreamer/blob/master/vignettes/hydrostreamer.Rmd"><code>vignettes/hydrostreamer.Rmd</code></a></small>
      <div class="hidden name"><code>hydrostreamer.Rmd</code></div>

    </div>

    
    
<p>The development of ‘hydrostreamer’ was inspired by my last study, where one component was estimating water availability in rural villages. In that study, we estimated it using a regional distributed hydrological model with 5km grid size, but I was unhappy with how it actually represented water quantities in the villages. First, the grid size was too large to represent the stream network accurately. Second, because the stream network was not usable, the results could only be taken as a continuous field. However, a continuous field of surface water hardly describes the tendency of water to flow in streams.</p>
<p>Hence, <strong>hydrostreamer</strong> was conceived. <strong>hydrostreamer</strong> takes an off-the-shelf runoff product of an arbitrary resolution, and assigns runoff to an explicitly represented river network. To keep things simple and approachable, there is no modelling involved in the use of <strong>hydrostreamer</strong>, rather, we post-process results from either hydrological or land sufrace models.</p>
<p>The concept of <strong>hydrostreamer</strong> is very simple and easy to grasp, and in fact it is nothing new. There are many solutions which use similar ideas (for instance HydroROUT, RAPID or mizuRoute). These also take off-the-shelf runoff products, and apply river routing algorithms to predict streamflow at explicit river segments. These solutions, however, may be difficult to use due to the technical skills required to install and use them, or they may be developed for licenced software. <strong>hydrostreamer</strong>’s focus is also not in river routing, but in the downscaling step.</p>
<div id="using-hydrostreamer" class="section level1">
<h1 class="hasAnchor">
<a href="#using-hydrostreamer" class="anchor"></a>Using <strong>hydrostreamer</strong>
</h1>
<p>Fictional example data is provided with the package for tutorial purposes. It contains a river network with 71 river segments, and runoff timeseries as GeoTIFF (12 layers; one for each month of the year). These are the minimum requirements, but I strongly suggest adding also an area of interest.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf)
<span class="co">#&gt; Linking to GEOS 3.6.1, GDAL 2.2.3, proj.4 4.9.3</span>
<span class="kw">library</span>(raster)
<span class="co">#&gt; Loading required package: sp</span>
<span class="kw">library</span>(hydrostreamer)

<span class="kw">data</span>(river)
<span class="kw">data</span>(basin)
runoff &lt;-<span class="st"> </span><span class="kw">brick</span>(<span class="kw">system.file</span>(<span class="st">"extdata"</span>, <span class="st">"runoff.tif"</span>, <span class="dt">package =</span> <span class="st">"hydrostreamer"</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(runoff[[<span class="dv">1</span>]])
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(river), <span class="dt">add=</span><span class="ot">TRUE</span>)
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(basin), <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-2-1.png" width="700"></p>
<p><strong>hydrostreamer</strong> workflow occurs in four steps (and four functions):</p>
<ol style="list-style-type: decimal">
<li>Convert the raster timeseries to a polygon grid</li>
<li>Compute weights for each river segments</li>
<li>Compute segment specific runoff</li>
<li>Apply river routing</li>
</ol>
<div id="converting-raster-to-a-polygon-grid" class="section level2">
<h2 class="hasAnchor">
<a href="#converting-raster-to-a-polygon-grid" class="anchor"></a>1. Converting raster to a polygon grid</h2>
<p>The raster layers are converted to polygons in order to do all the computations using only vector processing. each cell of the raster is polygonized, and if an area of interest is provided, the polygons are cropped to it. This removes any unneeded grid cells. The resulting ‘HSgrid’ object has an ID and surface area columns in addition to each timestep as their own columns.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span><span class="kw"><a href="../reference/polygrid_timeseries.html">polygrid_timeseries</a></span>(runoff, <span class="dt">aoi=</span>basin)
<span class="kw">names</span>(grid)
<span class="co">#&gt;  [1] "gridID"    "area_m2"   "runoff.1"  "runoff.2"  "runoff.3" </span>
<span class="co">#&gt;  [6] "runoff.4"  "runoff.5"  "runoff.6"  "runoff.7"  "runoff.8" </span>
<span class="co">#&gt; [11] "runoff.9"  "runoff.10" "runoff.11" "runoff.12" "geometry"</span>
<span class="kw">plot</span>(grid[,<span class="st">"area_m2"</span>])</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-3-1.png" width="700"></p>
</div>
<div id="compute-weight-for-each-river-segment-using-segment-catchments" class="section level2">
<h2 class="hasAnchor">
<a href="#compute-weight-for-each-river-segment-using-segment-catchments" class="anchor"></a>2. Compute weight for each river segment using segment catchments</h2>
<p>Once the raster has been polygonized, we can compute the weights. The function provides a possibility to weight the segments by their respective drainage area, or by using segment properties. If the catchment areas for each specific river segment are known, they can be provided. If not, <strong>hydrostreamer</strong> can estimate catchment areas using medial axis delineation (segment specific Voronoi polygons). Alternatively, if the river network is derived from a DEM, providing drainage direction raster allows <strong>hydrostreamer</strong> to delineate basins according to it.</p>
<p>Here, our river network is not a product of a DEM, so we’ll use medial axis delineation. The area of interest is important here as it is used to clip the voronoi polygons.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">voronoi &lt;-<span class="st"> </span><span class="kw"><a href="../reference/river_voronoi.html">river_voronoi</a></span>(river, <span class="dt">aoi=</span>basin, <span class="dt">riverID =</span> <span class="st">"ID"</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(voronoi[,<span class="st">"riverID"</span>], <span class="dt">reset=</span><span class="ot">FALSE</span>)
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(river), <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-5-1.png" width="700"></p>
<p>Each river segment now has a specific drainage area associated with it, and these can be used to weight. The voronoi creating step can be incorporated in the basin weighting step. here the third argument “area” tells the function that we’re using area-based weighting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v.weights &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compute_weights.html">compute_weights</a></span>(river, grid, <span class="st">"area"</span>, <span class="dt">aoi=</span>basin, <span class="dt">riverID =</span> <span class="st">"ID"</span>)</code></pre></div>
<p>If the basins were already calculated, we could also skip the extra delineation step by providing the basin areas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v.weights &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compute_weights.html">compute_weights</a></span>(river, grid, <span class="st">"area"</span>, <span class="dt">aoi=</span>basin, <span class="dt">basins =</span> voronoi, <span class="dt">riverID =</span> <span class="st">"ID"</span>)</code></pre></div>
<p>The output (‘HSragrid’) is a list of 3 objects:</p>
<ol style="list-style-type: decimal">
<li>a routed river network (created using <em>flow_network</em>)</li>
<li>weighted basins (in this case, weighted Voronoi diagram)</li>
<li>‘HSgrid’ object created earlier</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(v.weights[[<span class="dv">2</span>]][,<span class="st">"weights"</span>])</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-8-1.png" width="700"></p>
</div>
<div id="compute-weight-for-each-river-segment-using-segment-linestrings" class="section level2">
<h2 class="hasAnchor">
<a href="#compute-weight-for-each-river-segment-using-segment-linestrings" class="anchor"></a>2. Compute weight for each river segment using segment linestrings</h2>
<p>If the river network is very large, creating the catchment areas may take considerable amount of time. Alternative is to simply use the river segments and their properties for weighting. There are some important things to consider here. Runoff is allocated to the river segments only where they intersect the grid cells. In our example, this means that grid ID 4 on the left edge of the area of interest is not considered, because no river line crosses to that grid cell (see below).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(grid[,<span class="st">"gridID"</span>], <span class="dt">reset=</span><span class="ot">FALSE</span>)
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(river), <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-9-1.png" width="700"></p>
<p>Currently, <strong>hydrostreamer</strong> offers four ways to weight the segments:</p>
<ol style="list-style-type: decimal">
<li>equal weights (equally divide the grid cell value to all segments within)</li>
<li>Strahler stream order</li>
<li>Segment length</li>
<li>User provided numeric vector</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l.weights &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compute_weights.html">compute_weights</a></span>(river, grid, <span class="st">"length"</span>, <span class="dt">aoi=</span>basin, <span class="dt">riverID =</span> <span class="st">"ID"</span>)</code></pre></div>
<p>The function works a little bit different with segment-based weighting. The river network is first split at grid cell boundaries (using function <em>split_river_with_grid</em>). The segments are then routed with <em>flow_network</em>, and finally weighted based on the property defined. The output (‘HSrgrid’) is a list of 2 objects:</p>
<ol style="list-style-type: decimal">
<li>a split and routed river network</li>
<li>‘HSgrid’ object created earlier</li>
</ol>
</div>
<div id="compute-segment-spefic-runoff" class="section level2">
<h2 class="hasAnchor">
<a href="#compute-segment-spefic-runoff" class="anchor"></a>3. Compute segment spefic runoff</h2>
<p>After weighting, we can apply the actual downscaling.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v.runoff &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compute_segment_runoff.html">compute_segment_runoff</a></span>(v.weights)
l.runoff &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compute_segment_runoff.html">compute_segment_runoff</a></span>(l.weights)</code></pre></div>
<p>The output is the river network with additional runoff columns for each timestep (in our case, one for each month of the year).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v.runoff
<span class="co">#&gt; Simple feature collection with 71 features and 16 fields</span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 107.7396 ymin: 12.97917 xmax: 108.2521 ymax: 13.43333</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; First 10 features:</span>
<span class="co">#&gt;    riverID PREVIOUS NEXT                                    DOWNSTREAM</span>
<span class="co">#&gt; 1        1    -9999    3    3, 7, 8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 2        2    -9999    7       7, 8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 3        3     1, 4    7       7, 8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 4        4    5, 10    3    3, 7, 8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 5        5    -9999    4 4, 3, 7, 8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 6        6    -9999    8          8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 7        7     2, 3    8          8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 8        8     6, 7    9             9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 9        9    8, 12   14                14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt; 10      10   11, 20    4 4, 3, 7, 8, 9, 14, 15, 21, 25, 30, 33, 32, 26</span>
<span class="co">#&gt;           TS1         TS2         TS3         TS4        TS5        TS6</span>
<span class="co">#&gt; 1  0.05742213 0.009133529 0.007181127 0.016599013 0.17076607 0.43034150</span>
<span class="co">#&gt; 2  0.06418934 0.010209916 0.008027424 0.018555208 0.19089086 0.48105727</span>
<span class="co">#&gt; 3  0.01123945 0.001787741 0.001405590 0.003248989 0.03342470 0.08423239</span>
<span class="co">#&gt; 4  0.01434150 0.002281151 0.001793527 0.004145697 0.04264979 0.10748022</span>
<span class="co">#&gt; 5  0.08858261 0.014089896 0.011078011 0.025606570 0.26343333 0.66386898</span>
<span class="co">#&gt; 6  0.01466616 0.002332790 0.001834128 0.004239545 0.04361527 0.10991330</span>
<span class="co">#&gt; 7  0.02801368 0.004455839 0.003503350 0.008097914 0.08330911 0.20994432</span>
<span class="co">#&gt; 8  0.07473950 0.011888020 0.009346812 0.021604944 0.22226571 0.56012392</span>
<span class="co">#&gt; 9  0.19700751 0.066808547 0.049854856 0.107526692 0.32405957 0.63189319</span>
<span class="co">#&gt; 10 0.08964928 0.014259559 0.011211407 0.025914911 0.26660546 0.67186295</span>
<span class="co">#&gt;          TS7       TS8       TS9      TS10      TS11       TS12</span>
<span class="co">#&gt; 1  0.8560678 1.7738297 2.2708805 2.1261018 1.2260397 0.43533529</span>
<span class="co">#&gt; 2  0.9569554 1.9828757 2.5385039 2.3766630 1.3705285 0.48663958</span>
<span class="co">#&gt; 3  0.1675614 0.3471985 0.4444882 0.4161501 0.2399775 0.08520985</span>
<span class="co">#&gt; 4  0.2138078 0.4430240 0.5671652 0.5310059 0.3062103 0.10872745</span>
<span class="co">#&gt; 5  1.3206183 2.7364094 3.5031879 3.2798441 1.8913577 0.67157269</span>
<span class="co">#&gt; 6  0.2186478 0.4530529 0.5800044 0.5430265 0.3131421 0.11118876</span>
<span class="co">#&gt; 7  0.4176371 0.8653720 1.1078608 1.0372297 0.5981298 0.21238057</span>
<span class="co">#&gt; 8  1.1142408 2.3087814 2.9557328 2.7672917 1.5957888 0.56662374</span>
<span class="co">#&gt; 9  1.0059348 1.7084506 2.1471681 2.0682293 1.3455960 0.64266678</span>
<span class="co">#&gt; 10 1.3365205 2.7693598 3.5453715 3.3193383 1.9141325 0.67965942</span>
<span class="co">#&gt;                              geom</span>
<span class="co">#&gt; 1  LINESTRING (108.1354 13.429...</span>
<span class="co">#&gt; 2  LINESTRING (108.0979 13.433...</span>
<span class="co">#&gt; 3  LINESTRING (108.1187 13.414...</span>
<span class="co">#&gt; 4  LINESTRING (108.1396 13.410...</span>
<span class="co">#&gt; 5  LINESTRING (108.1771 13.429...</span>
<span class="co">#&gt; 6  LINESTRING (108.0792 13.416...</span>
<span class="co">#&gt; 7  LINESTRING (108.1021 13.410...</span>
<span class="co">#&gt; 8  LINESTRING (108.0687 13.406...</span>
<span class="co">#&gt; 9  LINESTRING (108.0229 13.389...</span>
<span class="co">#&gt; 10 LINESTRING (108.1729 13.356...</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(v.runoff[,<span class="st">"TS9"</span>], <span class="dt">reset=</span><span class="ot">FALSE</span>)
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(<span class="kw">st_cast</span>(grid, <span class="st">"LINESTRING"</span>)), <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-13-1.png" width="700"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(l.runoff[,<span class="st">"TS9"</span>], <span class="dt">reset=</span><span class="ot">FALSE</span>)
<span class="kw">plot</span>(<span class="kw">st_geometry</span>(<span class="kw">st_cast</span>(grid, <span class="st">"LINESTRING"</span>)), <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-13-2.png" width="700"></p>
<p>Some differences between the two approaches can be seen here: the long segment in the middle of the basin is split into shorter segments, when segment-based weighting is included. In catchment based weighting this is not automatically done (nothing stops the user from splitting the river network prior to creating the basins).</p>
</div>
<div id="apply-river-routing" class="section level2">
<h2 class="hasAnchor">
<a href="#apply-river-routing" class="anchor"></a>4. Apply river routing</h2>
<p>The last step is to accumulate flow downstream. The previous step only assigned the grid cell value to the streams. This may be usable in itself, e.g. if we were interested whether the water use in a specific segment is self-sufficient, or is dependent on flow from upstream. However, often we want to know the accumulated discharge at certain points of the river.</p>
<p><strong>hydrostreamer</strong> currently (June 2018) only implements the simplest possible river routing by adding all runoff to every segment downstream, at each timestep. This is an overly simple scheme, and there are plans to add more sophisticated river routing algorithms to the package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">v.flow &lt;-<span class="st"> </span><span class="kw"><a href="../reference/accumulate_flow.html">accumulate_flow</a></span>(v.runoff)
l.flow &lt;-<span class="st"> </span><span class="kw"><a href="../reference/accumulate_flow.html">accumulate_flow</a></span>(l.runoff)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(v.flow[,<span class="st">"TS9"</span>])</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-15-1.png" width="700"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(l.flow[,<span class="st">"TS9"</span>])</code></pre></div>
<p><img src="hydrostreamer_files/figure-html/unnamed-chunk-15-2.png" width="700"></p>
</div>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p><strong>hydrostreamer</strong> provides simple tools to downscale off-the-shelf runoff products without performing additional modelling. The package is under rapid development. Some planned upcoming features in future releases include:</p>
<ul>
<li>Add Muskingum river routing scheme</li>
<li>Analysis and plotting functions supporting observation data</li>
<li>Optimising an ensemble of several runoff products based on observed flow</li>
</ul>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#using-hydrostreamer">Using <strong>hydrostreamer</strong></a><ul class="nav nav-pills nav-stacked">
<li><a href="#converting-raster-to-a-polygon-grid">1. Converting raster to a polygon grid</a></li>
      <li><a href="#compute-weight-for-each-river-segment-using-segment-catchments">2. Compute weight for each river segment using segment catchments</a></li>
      <li><a href="#compute-weight-for-each-river-segment-using-segment-linestrings">2. Compute weight for each river segment using segment linestrings</a></li>
      <li><a href="#compute-segment-spefic-runoff">3. Compute segment spefic runoff</a></li>
      <li><a href="#apply-river-routing">4. Apply river routing</a></li>
      </ul>
</li>
      <li><a href="#conclusion">Conclusion</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Marko Kallio.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
