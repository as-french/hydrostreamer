---
title: "hydrostreamer tutorial GRUN"
author: "Andrew French (adapted from Marko Kallio's tutorial)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hydrostreamer tutorial GRUN}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}

# install version 1.0.1 for comaprison of
# hydrostreamer::accumulate_runoff(routing_method = "instant") with river Shannon data
# remotes::install_github("mkkallio/hydrostreamer")

# Ensure that vignette can be built or is not evaluated if all Suggests are not
# present (https://www.r-bloggers.com/2017/03/suggests-and-vignettes/)

required <- c("exactextractr","terra","ggplot2","plotly")

if (!all(unlist(lapply(required,
                       function(pkg)
                         requireNamespace(pkg, quietly = TRUE))))) {
  knitr::opts_chunk$set(eval = TRUE)
} else {
  knitr::opts_chunk$set(collapse = TRUE,
                        comment = "#>",
                        fig.width = 7,
                        fig.height = 7,
                        fig.align = "center")
 } # else {
#   knitr::opts_chunk$set(collapse = TRUE,
#                         comment = "#>",
#                         dev = "ragg_png",
#                         fig.width = 7,
#                         fig.height = 7,
#                         fig.align = "center")
# }
```

This tutorial aims to explain the workflow in `hydrostreamer` and showcase some
of its capabilities in relation to GRUN runoff timeseries grid data for the
river Shannon, Ireland. GRUN data were published under the CC By 4.0 license
(Ghiggi et al 2019). These data could be substituted with modelled runoff using
[`GR4J`](https://hydrogr.github.io/airGR/) or similar to translate gridded ECMWF
ERA5 reanlaysis (or SEAS5 seasonal forecast, or CMIP projections) precipitation
and evapotranspiration (or potential evapotranspiration derived from surface
temperature using the Hargreaves-Samani method) into gridded runoff.

# Using **hydrostreamer**

Some example data have been included to the package for tutorial purposes. It
includes:

1. ~45m resolution (~2.3arc second) DEM located in the west of Ireland. The DEM is
originally Mapzen Terrain Tiles, accessed using
[`elevatr`](https://github.com/jhollist/elevatr/).

```{r shannon_dem}
library(raster)

shannon_DEM = hydrostreamer::shannon_DEM
raster::res(shannon_DEM) # 45m

plot(shannon_DEM)
plot((sf::st_union(hydrostreamer::shannon_subcatchments)), add = TRUE)
```

2. ~0.5 degree runoff timeseries in the same area as the DEM. Runoff is sourced
from GRUN. The unit of runoff is mm/day, and are provided with a monthly
timestep.

```{r shannon_GRUN}
library(raster)
library(dplyr)
shannon_GRUN = hydrostreamer::shannon_GRUN
res(shannon_GRUN) # 0.5 0.5

plot(shannon_GRUN[[1]])
plot((sf::st_union(hydrostreamer::shannon_subcatchments) %>%
          sf::st_transform("EPSG:4326")), add = TRUE)
```

3. A digital river network of the river Shannon in Ireland, derived from
[EU-Hydro](https://land.copernicus.eu/en/products/eu-hydro?tab=main) with 2206
river segments. This river network can be represented by a directed acyclic
graph which contains distributaries/braids/islands. This network contains
[*"multiple
edges"*](https://igraph.org/r/doc/simplify.html#:~:text=Two%20edges%20are%20multiple%20edges,multiple%20edges%20from%20a%20graph)
and can therefore not be classified as a simple dendritic graph. One purpose of
this document is to demonstrate the capabilities of hydrostreamer for routing
discharge through this type of network. Currently, only
`hydrostreamer::accumulate_runoff(routing_method = "instant")` will work with
this type of network complexity. The function has been adapted to simply divide
the total upstream discharge of (for example) a distributary by the number of
immediate downstream edges/reaches, thereby each receives identical routed
discharge (e.g., 1/2 discharge of the upstream edge if there are two downstream
edges).

```{r eu_hydro_shannon}
library(sf)
shannon_rivers = hydrostreamer::shannon_rivers
plot(shannon_rivers$geom)
plot((sf::st_union(hydrostreamer::shannon_subcatchments)), add = TRUE)
```

4. River segment specific catchment areas, delineated using
`hydrostreamer::river_voronoi`. Catchments are provided for all (n = 2206) of
the river segments.

```{r shannon_catchments}
library(sf)
shannon_subcatchments = hydrostreamer::shannon_subcatchments
plot(shannon_subcatchments$geom)
```

Let's first load the data and inspect it:

```{r look_at_data}
library(hydrostreamer)
library(raster)
library(lubridate)
library(dplyr)
library(sf)

runoff <- hydrostreamer::shannon_GRUN

plot(hydrostreamer::shannon_GRUN[[2]]) 
plot((sf::st_union(hydrostreamer::shannon_subcatchments) %>%
          sf::st_transform("EPSG:4326")), add=TRUE)
plot((shannon_rivers %>% sf::st_transform("EPSG:4326")), add=TRUE,lwd = .5)

plot(shannon_DEM)
plot(shannon_subcatchments$geom, add=TRUE, lwd = .5)
plot((shannon_rivers$geom), add=TRUE, lwd = .5)
```


*hydrostreamer* main workflow occurs in three steps:

1. Areal interpolation of runoff to explicit river segments
2. Routing down the river network to estimate discharge
3. Model averaging, if streamflow observations are available.

## 1. Converting raster runoff to a polygon network

The raster layers are converted to polygons in order to do all the computations
using only vector processing, and thus. Each cell of the raster is polygonized,
and if an area of interest is provided, the polygons are clipped to it. This
removes any unneeded grid cells. The resulting **HS** object is a standard 'sf'
object with information about each raster cell. The runoff timeseries can be
found in a named list column *runoff_ts*. The elements are named by the ID, and
can be accessed with the '$' notation.

We use `hydrostreamer::raster_to_HS` to convert a raster timeseries to a HS
object.

```{r raster_to_HS}
library(dplyr)
library(terra)
library(raster)
aoi = sf::st_union(hydrostreamer::shannon_subcatchments)

# retrieve time var
GRUN_times = data.frame("Date" = raster::getZ(hydrostreamer::shannon_GRUN))

r <- terra::rast(hydrostreamer::shannon_GRUN)
terra::time(r) =  GRUN_times[,1] # time here

shannon_GRUN.rast <- raster::stack(hydrostreamer::shannon_GRUN)

aoi.rproj <- aoi %>%
    sf::st_transform(crs(shannon_GRUN.rast)) %>%
    sf::st_set_crs("EPSG:4326")

crs(shannon_GRUN.rast) <- crs(aoi.rproj)

#set nas to zero
shannon_GRUN.rast.rcls <-
    raster::reclassify(hydrostreamer::shannon_GRUN, cbind(NA, 0))

# plot check spatial overlap
plot(shannon_GRUN.rast.rcls$Runoff_1)
plot(sf::st_union(aoi.rproj), add = TRUE)

# -------------------------------------------------------------------------- #
# convert to HS object
source_runoff <-
    hydrostreamer::raster_to_HS(
        rasters = shannon_GRUN.rast.rcls,
        unit = "mm/day",
        date = lubridate::ymd(terra::time(r)[[1]]),
        timestep = "month",
        aoi = aoi.rproj,
        names = "GRUN",
        verbose = FALSE
    )

plot(source_runoff)
```

Inspect runoff timeseries for individual grids. 

```{r plot_timeseries_runoff_grid_i}
# access runoff timeseries of the element with ID `1` 
plot((source_runoff$runoff_ts$`1`$Date %>% as.Date()),
     source_runoff$runoff_ts$`1`$GRUN,
     type = "l",
     xlab = "Date",
     ylab = "runoff (mm/day)"
)
```

HS objects can also be created from an 'sf' (polygon) object and a runoff
timeseries using function
[`hydrostreamer::create_HS`](https://mkkallio.github.io/hydrostreamer/reference/create_HS.html).

## 2. Areal interpolation

The four areal interpolation methods shown here are explained in more detail in
our recent (2019) conference paper
[here](https://mssanz.org.au/modsim2019/K8/kallio.pdf). The following figure is
from the publication, visualizing the different methods:

<!-- ![Figure 1. Conceptual presentation of the areal interpolation methods and their result. Panel A presents the catchment areas (A1) and ancillary variable (A2) derived from a Digital Elevation Model (A0). Panel B shows the result of applying Areal Interpolation (B1), Dasymetric Mapping (B2), Pycnophylactic Interpolation (B3) and combined Pycnophylactic-Dasymetric Interpolation (B4) to input runoff data (B0).](http://markokallio.fi/modsim_fig1_density.png) -->


### Area Weighted Interpolation

Hydrostreamer implements several different areal interpolation methods, all of
which can be accessed using the **interpolate_runoff** function. The simplest
form implemented in hydrostreamer is Area Weighted Interpolation (AWI), which
divides runoff from source zones to target river reaches.

```{r downscale_AWI}
library(sf)

# check spatial overlap
# need to transform back to original EPSG:3035 of basins. Otherwise vertices
# become duplicates with transformation to WGS84 (EPSG:4326)).
rivers = (hydrostreamer::shannon_rivers %>%
            sf::st_transform("EPSG:3035") %>%
            sf::st_set_crs("EPSG:3035"))
basins = (hydrostreamer::shannon_subcatchments %>%
        sf::st_transform("EPSG:3035") %>%
        sf::st_set_crs("EPSG:3035"))
HS = source_runoff %>% 
    sf::st_transform("EPSG:3035") %>%
    sf::st_set_crs("EPSG:3035")

plot(HS$geometry, lwd = .5)
plot(basins$geom, add = TRUE, lwd = .5, col = "lightgreen")
plot(rivers$geom, add = TRUE, lwd = .5, col = "blue")

AWI <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    basins = basins,
    riverID = "riverID",
    verbose = FALSE
)
```

The output contains the columns from basins, added with riverID and runoff
timeseries converted to volume (cubic meters per second).

```{r plot_AWI}

plot((AWI$runoff_ts$`14970`$Date %>% as.Date()),
     AWI$runoff_ts$`14970`$GRUN,
     type = "l",
     xlab = "Date",
     ylab = "runoff (m3/s)"
)

# Filter time series to may june runoff before averaging. Could select flow from
# percentiles, but might be unreliable if missing data. mean runoff is m3/s.
AWI$mean_runoff <- sapply(AWI$runoff_ts, function(x){
  # filter may june
  x$month = lubridate::month(x$Date)# %>%
  mean_runoff = mean(x$GRUN[x$month %in% c(5,6)])
  return(mean_runoff)
})
plot(AWI[,"mean_runoff"])
```


### Dasymetric Mapping

We can also refine the estimates using a dasymetric variable. Here I assume that
more runoff is generated at higher elevations than lower, which may or may not
be a good assumptions. It is, however, easy to extract from the DEM.

In dasymetric mapping (DM), the output of area weighted interpolation is further
refined by scaling it using an ancillary variable - in this case elevation.

```{r downscale_DM}
library(dplyr)
basins = hydrostreamer::shannon_subcatchments %>%
    sf::st_transform(sf::st_crs(shannon_DEM))
    
elevation_values <- exactextractr::exact_extract(
    x = shannon_DEM,
    y = basins,
    fun = "mean",
    append_cols = c("riverID"),
    progress = FALSE
) %>%
    dplyr::rename(elevation = mean)

basins = basins %>%
    dplyr::left_join(elevation_values, by = "riverID") %>%
        sf::st_transform("EPSG:3035") %>%
        sf::st_set_crs("EPSG:3035")

DM <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    basins = basins,
    dasymetric = "elevation",
    riverID = "riverID",
    verbose = FALSE
)

DM$mean_runoff <- sapply(DM$runoff_ts, function(x) mean(x$GRUN))
plot(DM[,"mean_runoff"])
```

### Pycnophylactic Interpolation

A third possibility is to use Pycnophylactic Interpolation (PP).

```{r downscalePP}
source_runoff$mean_runoff <-
    sapply(source_runoff$runoff_ts, function(x) {
        mean(x$GRUN)
    })

HS = source_runoff %>% 
    sf::st_transform("EPSG:3035") %>%
    sf::st_set_crs("EPSG:3035")

PP <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    basins = basins,
    pycnophylactic = "mean_runoff",
    riverID = "riverID",
    verbose = FALSE
)

PP$mean_runoff <- sapply(PP$runoff_ts, function(x) mean(x$GRUN))
plot(PP[,"mean_runoff"])
```


### Combined Pycnophylactic - Dasymetric Interpolation

The fourth option is to use a combination of PP and DM. In this case, PP is
first performed instead of AWI, followed by the same scaling process with the
dasymetric variable.

```{r downscale_PPDM}
PPDM <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    basins = basins,
    dasymetric = "elevation",
    pycnophylactic = "mean_runoff",
    riverID = "riverID",
    verbose = FALSE
)
PPDM$mean_runoff <- sapply(PPDM$runoff_ts, function(x)
    mean(x$GRUN))
plot(PPDM[, "mean_runoff"])
```



### Area-to-Line interpolation

All of the above examples are using catchment areas as the target units where
runoff is estimated. However, existing vector-based river network data may not
come specified with the DEM they were created with, or the processing steps are
not clearly defined. In such cases, delineating the catchment areas for each
segment may be difficult or outright impossible. For such cases, hydrostreamer
provides the possibility to do interpolation from the source areas to
linestrings. In such case, interpolation is based on the length of the
linestring instead of the polygon area.

```{r downscale_A2L}

A2L <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    riverID = "riverID",
    verbose = FALSE
)

A2L$mean_runoff <- sapply(A2L$runoff_ts, function(x)
    mean(x$GRUN))
plot(A2L[, "mean_runoff"])

# DASYMETRIC MAPPING WITH LINES

A2LDM <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    dasymetric = "gmean_m",
    riverID = "riverID",
    verbose = FALSE
)

A2LDM$mean_runoff <-
    sapply(A2LDM$runoff_ts, function(x)
        mean(x$GRUN))
plot(A2LDM[, "mean_runoff"])
```


### Using both lines and basins

The last example shown here is using both linestrings, and their respective
catchment areas. The advantage here is that we can represent the rivers as they
are in the network - as connected lines - and still use the catchment areas as a
more accurate representation of the runoff produced in the catchment of the
segment. In addition, using the lines allows us to use the constant river
routing algorithm in the next step instead of only instantaneous routing.

```{r downscale_RB}
RB <- hydrostreamer::interpolate_runoff(
    HS = HS,
    river = rivers,
    dasymetric = "elevation",
    basins = basins,
    riverID = "riverID",
    verbose = FALSE
)

RB$mean_runoff <- sapply(RB$runoff_ts, function(x)
    mean(x$GRUN))
plot(RB[, "mean_runoff"])
```

## 3. Apply river routing

While the runoff generated at each river segment is already useful for many
applications, knowing river discharge is often also desirable. hydrostreamer
provides two simple river routing algorithms for this purpose: **instantaneous**
routing, useful for e.g. estimating runoff in the entire upstream catchment of
each river segment, and **constant** flow velocity routing.

Each routing method is accessible through the function *accumulate_runoff()*.
Since the catchment provided here is small, and the timestep in runoff is one
month, we'll just use instantaneous routing here. There would be negligible
difference between constant velocity and instantaneous routing in this case.

However, we cannot use the catchments-only downscaled runoff here directly
because there is no routing information. Since we can derive the routing
information for the river lines, we can use that same routing info for the
catchments also.

Note that running *river_network()* is not explicitly necessary, since the
routing algorithm does it automatically if it has not been run in advance.

```{r routing_amber_HS_compare}
# # load river, add lookup information, collate all upstream segments
routed_river_hydrostreamer <-
    river_network(hydrostreamer::shannon_rivers,
                  riverID = "riverID",
                  verbose = FALSE)


# ----------------------------------------------------------------------- #

# add routing information LEFT JOIN, not cbind
routed_river_hydrostreamer_NPID = routed_river_hydrostreamer %>%
    dplyr::select(riverID, NEXT, PREVIOUS, UP_SEGMENTS) %>%
    sf::st_drop_geometry()

PPDM.join = dplyr::left_join(PPDM,
                             routed_river_hydrostreamer_NPID,
                             by = "riverID")

RB.join = dplyr::left_join(RB,
                           routed_river_hydrostreamer_NPID,
                           by = "riverID")
```


```{r plot_routing1}
catchment_discharge <-
    hydrostreamer::accumulate_runoff(PPDM.join,
                                     routing_method = "instant",
                                     verbose = FALSE)
river_discharge <-
    hydrostreamer::accumulate_runoff(RB.join,
                                     routing_method = "instant",
                                     verbose = FALSE)

#catchment_discharge$mean_discharge <- sapply(catchment_discharge$discharge_ts, function(x) mean(x$GRUN))
catchment_discharge$mean_discharge <-
    sapply(catchment_discharge$discharge_ts, function(x) {
        # filter may june
        x$month = lubridate::month(x$Date)# %>%
        mean_discharge = mean(x$GRUN[(x$month %in% c(5, 6))])
        return(mean_discharge)
    })

#river_discharge$mean_discharge <- sapply(river_discharge$discharge_ts, function(x) mean(x$GRUN))

river_discharge$mean_discharge <-
    sapply(river_discharge$discharge_ts, function(x) {
        # filter may june
        x$month = lubridate::month(x$Date)# %>%
        mean_discharge = mean(x$GRUN[(x$month %in% c(5, 6))])
        return(mean_discharge)
    })

library(ggplot2)
#library(plotly)
# https://colorbrewer2.org/#type=sequential&scheme=Blues&n=3
p1 <- river_discharge %>%
    ggplot() +
    geom_sf(aes(geometry = geom, col = mean_discharge)) +
    scale_color_gradient(name = "Discharge (m3/s)",
                         low = "#bdd7e7",
                         high = "#08519c") +
    labs(title = "mean discharge (May-June)") +
    theme_bw()

# overall plot
p1

# to zoom in and check discharge distribution at braids/distributaries/islands
#plotly::ggplotly(p1)

```

The algorithm adds a new list column discharge_ts, containing the routed
discharge estimates.

We can also plot the estimated discharge from the two approaches at segment
riverID 14970 by accessing the new list column *discharge_ts*.

```{r plot_routing2}
plot(catchment_discharge$discharge_ts$`14970`, type = 'l')
lines(river_discharge$discharge_ts$`14970`, col = 'red')
title(main = "PPDM discharge in black, and Area-to-Line discharge in red.",
      sub = "Unit = m3/s, riverID = `14970`")
```

As seen from the plots, in this catchment the difference between PPDM and
Area-to-Line Interpolation is very small. In fact, we've found that as the basin
size increases, the difference becomes increasingly small. This is particularly
true for discharge at a monthly timestep. Larger difference can be expected with
a daily timestep and with constant flow velocity routing.

## Footnote on caveats and future possibilities

Note that the Shannon catchment contains large lakes and multiple in-river
structures that influence the flow regime, including large flow-altering
hydroelectric structures. The aim of this example was simply to demonstrate
package functionality for a braided river network; it was not to estimate
accurate discharges at high temporal resolution. Nevertheless, the above
temporally aggregated estimates of discharge calculated at reach resolution
might be useful for estimating river geometries (e.g., widths and depths) from
approximate relationships (e.g., Manning's equation), which could be useful for
estimating habitat availability (e.g., for diadromous fishes). Possible future
work might include: (i) comparison and statistical bias adjustment of reach
scale estimates against gauge data; (ii) routing discharge at higher temporal
resolution and with different routing algorithms.

## References

T. Tadono, H. Ishida, F. Oda, S. Naito, K. Minakawa, H. Iwamoto : Precise Global
DEM Generation By ALOS PRISM, ISPRS Annals of the Photogrammetry, Remote Sensing
and Spatial Information Sciences, Vol.II-4, pp.71-76, 2014.

Hobeichi, S., Abramowitz, G., Evans, J., and Beck, H. E.: Linear Optimal Runoff
Aggregate (LORA): a global gridded synthesis runoff product, Hydrol. Earth Syst.
Sci., 23, 851-870, https://doi.org/10.5194/hess-23-851-2019, 2019.

Ghiggi, G., Humphrey, V., Seneviratne, S. I., and Gudmundsson, L.: GRUN: an
observation-based global gridded runoff dataset from 1902 to 2014, Earth Syst.
Sci. Data, 11, 1655–1674, https://doi.org/10.5194/essd-11-1655-2019, 2019.
